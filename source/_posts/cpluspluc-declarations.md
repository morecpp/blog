---
title: C++ 声明
date: 2019-05-18 15:41:45
categories: "C++"
tags: 
	- C++
---
声明是将名字引入（或再引入）到C++程序中，每种实体的声明方式都不相同，[**定义**]()是足以使该名字所标识的实体被使用的声明，声明是下列之一：
<!--more-->
***
* [**函数定义**]()
* [**模板声明**]()包括部分模板特化）
* [**显示模板实例化**]()
* [**显示模板特化**]()
* [**命名空间定义**]()
* [**链接说明**]()
* 属性声明（attr;）（c++ 11起）
* 空声明（;）（C++11起）
* 无 `decl-specifier-seq:`（声明说明符）的函数序列
***
`attr`（可选） 声明符 ;
***
attr （C++11 起）- 任意数量属性的序列
		  声明符 - 函数声明符
此声明必须声明构造函数、析构函数或用户定义的类型[**转换函数**](),它只能用作[**模板声明**]()、[**显式特化**]或显式实例化的一部分。
块声明（能出现于[**块**]()中的声明），它可以是下列之一：
***
* [**汇编定义**]()
* [**类型别名声明**]()（C++ 11起）
* [**命名空间别名定义**]()
* [**using声明**]()
* [**using指令**]()
* [**static_assert声明**]()（C++ 11起）
* [**不可见enum声明**]()
* 简单声明

## 简单声明
简单声明是引入、创建并可选地初始化一个或数个标识符（典型地为变量）的语句。
***
声明说明符序列 初始化声明符列表(可选) ;	(1)	
***
attr 声明说明符序列 初始化声明符列表;	(2)	
***
```CPP
attr (C++11  起)	              -	任何数量属性的序列
声明说明符序列（decl-specifier-seq）    -	说明符（specifier）的序列（见下文）。
初始化声明符列表（init-declarator-list）-	带可选的初始化器（initializer）的声明符（declarator）的逗号分隔列表。初始化声明符列表 在声明具名的 class/struct/union 或具名枚举时是可选的
结构化绑定声明亦为简单声明。 (C++17 起)
```
## 说明符

声明说明符（声明说明符序列）是下列以空白分隔的说明符的序列，顺序任意：
* [**typedef**]()说明符，若存在，则整个声明是[**typedef声明**]()，且每个声明符引入一个新的类型名，而非对象或函数。
* 函数说明符（[**inline**]()、[**virtual**]()、[**explicit**]()），仅在函数声明中允许使用。
* [**inline**]()说明符亦允许在变量上使用。（c++ 17起）
* [**friend**]()说明符允许在类和函数声明中使用。
* [**constexpr**]()说明符，只允许在变量定义，函数及函数模板声明，以及具有字面类型的静态数据成员的声明中使用。（c++11 起）
* [**consteval**]()说明符，只允许在函数和函数模板中使用。（c++20 起）
* [**存储类**]()说明符（[**register**]()、[**static**]()、[**thread_local**]()（c++11 起）、[**extern**]()、[**mutable**]()）。仅允许使用一个存储类型说明符，但 **thread_local**可以和 **extern** 或 **static**一同出现。
* **类型说明符**（*类型说明符序列*），指名一个类型的说明符的序列。声明所引入的每个实体均为此类型，可选地为声明符所修饰（见下文）。这个说明符序列也被[**类型标识**]()（type-id）所用。唯有下列说明符是 类型说明符序列 的一部分，顺序任意：
	* [**类说明符**]()
	* [**枚举说明符**]()
	* 简单类型说明符
		* char,char8_t（c++20 起），char16_t，char32_t（c++11 起），wchar_t，bool，short，int，long，signed，unsigned，float，double，void。
		* [**auto**]()（c++11 起）
		* [**decltype说明符**]()（c++11 起）
		* 先前声明过的类名（可选的限定）
		* 先前声明过的枚举名（可选的限定）
		* 先前声明过的[**typedef-name**]()或 [**类型别名**]()（c++11 起）（可选的限定）
		* 带模板实参的模板名（可选的限定，可选地用 [**template消歧义符**]()）
		* 无模板实参的模板名（可选的限定：参阅[**模板实参推到**]()（c++17 起）
	* [**详细的类型说明符**]()
		* 关键字class、struct或union，后随先前已定义为class、struct或union名的标识符（可选的限定）。
		* 关键字class、struct或union，后随带模板实参的，先前已定义为类模板名字的模板名，（可选的限定，可选的[**template消歧义符**]()）
		* 关键字euum后随先前已经定义为枚举的标识符（可选的限定）
	* [**typename 说明符**]()
	* [**cv限定符**]()

每个*声明说明符序列*只允许出现一个类型说明符，但有以下例外：
***
* const能与自身外的任何类型说明符组合。
* volatile能与自身外的任何类型说明符组合。
* signed或unsigned能与char、long、short或int组合。
* short或long能与int组合。
* long能与double组合。
* long能与long组合。（c++11 起）
属性可以出现与*声明说明符序列*中，该情况下它们应用于其之前的说明符所确定的类型。
*声明说明符序列* **中仅有的允许两次出现的说明符是long**（可出现两次）。所有其它重复，例如const static const或virtual inline virtual均为错误

## 声明符
*初始化声明符列表*（init-declarator-list）是一个或多个初始化说明符，它拥有下列语法：
***
*声明符 初始化器（可选）*  (1) 
***
*声明符 requres-clause* （2）
***
声明符（declarator）- 声明符
初始化器（initializer）- 可选的初始化器（除非在必要场合，例如初始化引用或const对象时）。详细细节见[**初始化**]()
requires-字句（c++20 起）- requires-clause，向函数声明添加制约
初始化声明序列 `S D1,D2,D3;` 中的每个初始化声明符，均按照如同它是拥有相同说明符的孤立声明来处理：
`S D1,S D2,S D3;`。
每个声明符恰好引入一个对象、引用、函数或（对于typedef声明）类型别名，其类型由声明说明符序列提供，并可选地被声明符中的运算符，如 `&` （引用）或者 `[]`（数组）或 `()`（函数返回）所修饰。可以递归这些运用说明符，如下所示：
***
*(1)unqualified-id attr(optional)*	                                	
***
*(2)qualified-id attr(optional)*	                               	
***
*(3)... identifier attr(optional)*	                               	(since C++11)
***
*(4)attr(optional) cv(optional) declarator*	                   	
***
*(5)nested-name-specifier `*`attr(optional) cv(optional) declarator*	
***
*(6)& attr(optional) declarator*                          				
***
*(7)&& attr(optional) declarator*										(since C++11)
***
*(8)noptr-declarator [ constexpr(optional) ] attr(optional)*			
***
*(9)noptr-declarator ( parameter-list ) cv(optional) ref(optional) except(optional) attr(optional)*		
***
* 1、所声明的名称
* 2、使用有限定的标识符定义或重声明先前声明的命名空间成员或成员的声明符
* 3、形参包，仅出现于形参声明中。
* 4、指针声明符：声明`S *D;`将D声明为指向*声明说明符序列*所确定的类型S的指针。
* 5、成员指针说明：声明`S C::*D;`将D声明为指向C中的类型为*声明说明符序列*所确定的类型S的成员指针。*嵌套名说明符*为名字和作用域解析运算符`::`的序列
* 6、左值引用说明符：声明`S & D;`将D声明为到*声明说明符序列*所确定的类型S的左值引用。
* 7、右值引用说明符：声明`S && D`将D声明为到*声明说明符序列*所确定的类型S的右值引用。
* 8、数组声明符。noptr-声明符 为任何合法声明符，但若它以 `*、``&` 或 `&&` 起始，则必须用括号环绕它。
* 9、 函数声明符。noptr-声明符 为任何合法声明符，但若它以 `*、`&` 或 `&&` 起始，则必须用括号环绕它。注意最外层函数声明符可以可选的尾随返回类型结尾。
未完待续...