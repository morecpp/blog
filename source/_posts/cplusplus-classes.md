---
title: C++ 类
date: 2019-05-18 08:22:52
categories: "C++"
tags: 
	- C++
---
类是用户定义的类型 
类类型由类的说明符定义，它出现在声明语法的 `decl-specifier-seq` 中，类的说明符具有以下语法：
<!--more-->

***
class-key attr class-head-name { member-specification }	                        (1)	

class-key attr class-head-name : base-specifier-list { member-specification }	(2)	
***

```cpp
	   class-key - class,struct,union关键字中的一个
         attr(c++11) - 任意数量可选的属性序列
     class-head-name - 正在定义的类的名称，可选的nested-name-specifier（名称和范围解析运算符的序列，以范围解析运算符结尾）操作，可选的后跟关键字final。类名称可以省略，这种情况下类名是未命名的（注意，未命名的类是不可以用final限定的）

 base-specifier-list - 一个或多个父类的列表以及每个父类使用的继承模型（请参见派生类）
member-specification - 访问说明符列表，成员对象和成员函数声明和定义（请参阅类定义）
```

类的关键字 `struct` 和 `class` 在C++作用是基本相同的，唯一的区别是：如果类的声明使用关键字 `struct` 则默认访问模式和默认继承模式为公有，如果类的声明使用关键字 `class` 则默认访问模式和默认继承模式为私有。 `class` 和 `struct` 都可以在类定义中使用。如果类的定义使用关键字 `union` 则产生联合定义，该定义产生的类一次只保存其一个数据成员。

## 一个类可以有以下种类的成员
* 数据成员（data members）
	* 非静态数据成员，包括位字段（`bit fields`）
    * 静态数据成员
* 成员函数
    * 非静态成员函数
    * 静态成员函数
* 嵌套类型
    * 在类内部定义的嵌套和枚举
    * 现有类型的别名，使用 `typedef` 或类型别名声明定义
    * 为了查找的目的，它自己定义中的类的名称充当其自身的公共成员类型别名（除非用于命名构造函数）：这称为 `inject-class-name`
* 来自类中定义的所有未作用域枚举的枚举类
* 成员模板（变量模板，（since C ++ 14）类模板或函数模板）可能出现在任何非本地 class/struct/union的主体中。
***
1、 所有成员都在类中一次性定义，不能向已定义的类添加成员（这不同于命名空间的成员）
2、类 T 的成员，若它是静态数据成员、成员函数、成员类型、成员模板、无作用域枚举的枚举项、匿名成员联合体的成员，则不能使用 T 作为其名字。然而，非静态数据成员可使用名称 T ，只要无用户声明的构造函数。
3、具有至少一个声明或继承的虚拟成员函数的类是多态的。这种类型的对象是多态对象，并且具有作为对象表示的一部分存储的运行时类型信息，可以使用 `dynamic_cast` 和 `typeid` 查询。 虚拟成员函数参与动态绑定。
4、具有至少一个声明或继承的纯虚成员函数的类是抽象类。无法创建抽象类型的对象。
具有 `constexpr` 构造函数的类是 `LiteralType`：此类型的对象可以在编译时由 `constexpr` 函数操作。
5、一些成员函数是特殊的：某些条件下，即使用户不定义，编译器也会定义它们。它们是：
***
* 默认构造函数
* 复制构造函数
* 移动构造函数 (C++11 起)
* 复制赋值运算符
* 移动赋值运算符 (C++11 起)
* 析构函数 
